" Defaults

source $VIMRUNTIME/defaults.vim

" Options

set autoindent
set autoread
set breakindent
set clipboard=unnamedplus,exclude:cons\|linux
set expandtab
set exrc
set formatoptions-=tro
set hidden
set hlsearch
set ignorecase
set incsearch
set modeline
set mouse=a
set nonumber
set path=**
set secure
set shiftround
set shiftwidth=0
set smartindent
set softtabstop=4
set splitbelow
set splitright
set t_md=
set tabstop=4
set title
set ttimeoutlen=10
set ttymouse=urxvt
set whichwrap=b,s,<,>,[,]

set visualbell
set t_vb=

colorscheme default
highlight LineNr ctermfg=8

" Plugins

try
    call plug#begin('~/.vim/plugged')
        Plug 'scrooloose/nerdtree'
        let NERDTreeMinimalUI = 1

        Plug 'scrooloose/nerdcommenter'
        let NERDSpaceDelims = 1
        let NERDDefaultAlign = 'left'
        let NERDCommentEmptyLines = 1
        let NERDToggleCheckAllLines = 1

        Plug 'tpope/vim-surround'

        Plug 'tpope/vim-fugitive'

        Plug 'lilydjwg/colorizer'

        Plug 'mhinz/vim-startify'
        let startify_custom_header = split(system('toilet -f mono12 vim'), '\n')
        let g:startify_files_number = 5
        let g:startify_lists = [
          \ { 'type': 'dir',   'header': ['Recent files in '.getcwd()] },
          \ { 'type': 'files', 'header': ['Recent files']              },
        \ ]
    call plug#end()
catch
endtry

" Mappings

let mapleader = ','

noremap           <Home>           ^
imap              <Home>           <C-o><Home>
nnoremap <silent> <Return>         :noh<Bar>echo<Return>
noremap           p                ]p
vnoremap          //               y/\V<C-r>=escape(@",'/\')<Return><Return>
vnoremap          ??               y?\V<C-r>=escape(@",'?\')<Return><Return>
noremap  <silent> <C-l>            :set number!<Return>
noremap  <silent> <C-c>            :call NERDComment(0, 'toggle')<Return>
noremap  <silent> <C-n>            :NERDTreeToggle<Return>
noremap           <C-p>            :find<Space>
cnoremap          <C-p>            <Home>vert s<End>
noremap           <C-Left>         <C-w>h
noremap           <C-Right>        <C-w>l
noremap           <C-Down>         <C-w>j
noremap           <C-Up>           <C-w>k
noremap  <silent> <C-s>            :update<Return>
noremap  <silent> <C-t>            :ToggleTerm<Return>
tnoremap <silent> <C-t>            <C-w>:ToggleTerm<Return>
noremap  <silent> <Leader><Leader> :map <Leader><Return>
noremap           <Leader>mm       :make<Return>
noremap           <Leader>mi       :make install<Return>
noremap           <Leader>mc       :make clean<Return>
noremap           <Leader>m<Space> :make<Space>
noremap           <Leader>i        :AddImport<Bar>SortImports<Return>
nnoremap          <Leader>r        :%s///g<Bar>''<Left><Left><Left><Left><Left>
noremap  <silent> <Leader>s        :sort<Return>
noremap  <silent> <Leader>u        :write !upload<Return>
noremap  <silent> <Leader>x        :execute '!chmod +x -- '.shellescape(@%)<Return>

" Autocommands

autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | quit | endif " quit if NERDTree is the last buffer
autocmd BufWritePre * %s/\s\+$//e " trim leading whitespace on save

autocmd BufNewFile,BufRead ~/.dots/bash/* call dist#ft#SetFileTypeSH("bash")

autocmd BufWritePost * if getline(1) =~ '^#!' && !executable(expand('%:p')) | silent execute '!chmod +x -- '.shellescape(@%) | endif

" Commands

command! ToggleTerm call ToggleTerm()
command! -nargs=* -bar AddImport call AddImport(<f-args>)
command! SortImports 1/^import /,$?^import ?sort u /^import \+/ | nohlsearch

" Functions

function! ToggleTerm()
    if &buftype == 'terminal'
        close
        return
    endif

    let terminal_windows = filter(getwininfo(), 'v:val.terminal')
    if !empty(terminal_windows)
        execute terminal_windows[0].winnr.'wincmd w'
        return
    endif

    let terminal_buffers = filter(getbufinfo(), 'getbufvar(v:val.bufnr, ''&buftype'') == ''terminal''')
    if !empty(terminal_buffers)
        execute 'botright sbuffer' terminal_buffers[0].bufnr
        return
    endif

    botright terminal ++close ++kill=term ++norestore
endfunction

function! AddImport(...)
    if !exists('$IMPORTPATH')
        echoerr 'IMPORTPATH not set'
        return
    endif

    let $TYPENAME = get(a:, 1, expand('<cword>'))
    let types = systemlist('IFS=: read -ra jars <<< "$IMPORTPATH"; for f in "${jars[@]}"; do jar -tf "$f" 2> /dev/null; done | sed -n ''/\<''"$TYPENAME"''\.class$/{s/\.class$//;s,/,.,g;p}''')

    if len(types) == 0
        return
    elseif len(types) == 1
        let type = types[0]
    else
        for i in range(len(types))
            echo i types[i]
        endfor
        let type = get(types, input('Which type do you want to import? '))
    endif

    let v:errmsg = ''
    silent! $?^import
    if v:errmsg != ''
        silent! $?^package
        normal o
    endif

    put ='import '.type.';'
endfunction
