# Files

pwd_short() {
    set +x # avoid polluting xtrace output in interactive shells
    local pwd=$PWD user home component i prefix
    while IFS=: read -r user _ _ _ _ home _; do
        if [[ $home == @(/home/*|/root|/var/lib/*|/srv/*) && $pwd == "$home"?(/*) ]]; then
            if [[ $user == $USER ]]; then
                pwd=${pwd/#"$home"/'~'}
            else
                pwd=${pwd/#"$home"/'~'"$user"}
            fi
            break
        fi
    done < <(getent passwd)
    while IFS= read -rd/ component; do
        i=0
        while
            prefix=${component::++i}
            [[ $prefix == +(.) ]]
        do :; done
        printf %s/ "$prefix"
    done <<< "$pwd"
    printf '%s\n' "$component"
}

cd() {
    builtin cd "$@" && ls
}

mkcd() {
    mkdir -p "$@" && builtin cd "$@"
}

bck() {
    local f
    for f do
        cp -i -- "$f" "$f.bck"
    done
}

unbck() {
    local f
    for f do
        if [[ $f == *.bck ]]; then
            cp -i -- "$f" "${f%.bck}"
        else
            cp -i -- "$f.bck" "$f"
        fi
    done
}

flast() {
    local print_time=0 n=+1 o OPTIND OPTARG
    while getopts :tn: o; do case $o in
        t) print_time=1;;
        n) n=$OPTARG;;
    esac done; shift "$(( OPTIND - 1 ))"
    find "${@:-.}" -type f -printf '%T@/%P\0' | sort -znst / -k 1,1 | tail -zn "$n" |
    while IFS=/ read -rd '' time path; do
        (( print_time )) && printf '[%(%F %T)T] ' "${time%%.*}"
        printf '%s\n' "$path"
    done
}

# Disks

duh() {
    local lines=() total_size size file width=15 bar
    mapfile -t lines < <(command du -abd 1 "$@")
    read -r total_size _ <<< "${lines[-1]}"
    printf '%s\n' "${lines[@]::${#lines[@]}-1}" | sort -nrk 1,1 | while read -r size file; do
        bar=
        (( n = (width + 1) * (size - 1) / total_size))
        for (( i = 0; i < n; i++ )) do bar+='#'; done
        printf '%7s [%-*s] %s\n' "$(numfmt --to=iec-i --suffix=B "$size")" "$width" "$bar" "$file"
    done
}

mountl() {
    local label=$1
    sudo mkdir -p /mnt/"$label"
    sudo mount LABEL="$label" /mnt/"$label"
}

# Streams

sponge() {
    local tmp
    tmp=$(mktemp) || return 1
    cat > "$tmp"; cat -- "$tmp"
    rm -f -- "$tmp"
}

unfold() {
    tr -s '[:space:]' '[ *]'
}

clipcmd_helper () {
    local cmd
    local -a lines
    read -r _ _ cmd < <(history 1)
    mapfile lines < <(LC_ALL=en_US.UTF-8 eval "$cmd" 2>&1)
    printf %s "${lines[@]}"
    {
        printf '$ %s\n' "$cmd"
        printf %s "${lines[@]}"
    } | clip -n
}; alias clipcmd='clipcmd_helper # '

# SSH

attassh() {
    local host=$1 session=$2
    ssh -t "$host" screen -r "$session"
}

sshesc() {
    local args=() interactive=0 cmd
    while (( $# )); do
        if [[ $1 == -i ]]; then
            interactive=1
        elif [[ $1 == -- ]]; then
            shift
            if (( interactive )); then
                cmd=$*
                args=(-qt "${args[@]}" bash -lic "${cmd@Q}")
            else
                args+=("${@@Q}")
            fi
            break
        else
            args+=("$1")
        fi
        shift
    done
    ssh "${args[@]}"
}

# Network

myip() {
    dig +short myip.opendns.com @resolver1.opendns.com
}

http() {
    local port password source=${1-.} tmpdir response_fifo
    read -rp "Port? " port
    port=${port:-4242}
    if [[ -d $1 ]]; then
        read -rsp "Password? " password
        echo
        caddy -conf=<(echo ":${port:-12345}"; echo browse; [[ $password ]] && echo "basicauth / naim $password") ${1+-root="$1"}
    elif [[ -x $1 ]]; then
        [[ $source == */* ]] || source=./$source
        tmpdir=$(mktemp --tmpdir -d http-XXXXX) || return 1
        response_fifo=$tmpdir/reponse
        mkfifo "$response_fifo" || return 1
        echo "Serving $source at http://localhost:$port"
        while
            nc -l -p "$port" -N < "$response_fifo" | "$source" > "$response_fifo"
        do :; done
    else
        echo "Invalid source." >&2
    fi
}

wg-toggle() {
    local interface=wg0
    if systemctl -q is-active wg-quick@"$interface"; then
        sudo systemctl stop wg-quick@"$interface"
    else
        sudo systemctl start wg-quick@"$interface"
    fi
}

# Misc

args() {
    printf '%d\n' "$#"
    if (( $# )); then
        printf '<%s> ' "$@"
        echo
    fi
}

count() {
    printf '%d\n' "$#"
}

remind() {
    local delay=$1
    shift
    {
        sleep "$delay"
        exec dunstify -i dialog-info -t 10000 "$*"
    } &> /dev/null & disown
}

insist() {
    local command=("$@")
    until "${command[@]}"; do sleep 0.1; done
}

with() {
    local args
    while read -rep "${PS1@P}$* " args; do
        history -s "$args"
        eval "$* $args"
    done
    echo
}

what() {
    local thing=$1 path
    if [[ -e $thing ]]; then
        thing=$(realpath "$thing")
        [[ -d $thing ]] && thing+=/
    elif [[ $thing != */* ]]; then
        path=$(type -p "$thing")
        thing=${path:-/usr/bin/$thing}
    fi
    pacman -Fo "$thing"
}

man() {
    if [[ $1 != -* && $2 == -* ]]; then
        command man -P "less -+ij3 +'/^[[:space:]]*'${2@Q}" "$1"
    else
        command man "$@"
    fi
}

rfc() {
    local -A codes=([ascii]=20 [udp]=768 [ip]=791 [icmp]=792 [tcp]=793 [arp]=826 [ftp]=959 [dns]=1034 [dns2]=1035 [ipoac]=1149 [imap2]=1176 [md5]=1321 [irc]=1459 [imap4]=1730 [netiquette]=1855 [private]=1918 [pop3]=1939 [http1]=1945 [http]=1945 [keywords]=2119 [dhcp]=2131 [tls1]=2246 [ipv6]=2460 [ipoac2]=2549 [irc2]=2810 [ircc]=2812 [ircs]=2813 [nat]=3022 [punycode]=3492 [utf8]=3629 [sasl]=4422 [sha]=4634 [smtp]=5321 [websocket]=6455 [oauth]=6749 [http2]=7540)
    local i
    for i do
        [[ -v 'codes[$i]' ]] && i=${codes[$i]}
        ${PAGER:-less} /usr/share/doc/rfc/txt/rfc"$i".txt
    done
}

# EFI

efibootorder() {
    local field value boot_order=() boot_entries=()
    while read -r field value; do
        if [[ $field == BootOrder: ]]; then
            IFS=, read -ra boot_order <<< "$value"
        elif [[ $field =~ ^Boot([0-9A-F]+) ]]; then
            boot_entries[16#${BASH_REMATCH[1]}]=$value
        fi
    done < <(efibootmgr)
    for i in "${boot_order[@]}"; do
        printf -- '- %s\n' "${boot_entries[16#$i]}"
    done
}

# Python

pyv() {
    local root=.
    until [[ -d $root/.venv ]]; do
        if [[ $root -ef / ]]; then
            return 1
        fi
        root+=/..
    done
    if (( $# )); then
        (. "$root"/.venv/bin/activate; "$@")
    else
        . "$root"/.venv/bin/activate
    fi
}

# Vultr

vultr() {
    local args=() sub=() name subid
    local preset_paris=(-r 24)
    local preset_350=(-p 200)
    local preset_1000=(-p 202)
    local preset_2000=(-p 203)
    local preset_archiso=(-o 159 --iso=417463)
    local preset_ubuntu=(-o 270)
    [[ -f ~/.vultr ]] && . ~/.vultr
    for arg do
        sub=()
        case $arg in
            NAME=*)
                subid=$(command vultr server list | awk -F'\t+' -v name="${arg#NAME=}" 'NR > 1 && $4 == name { print $1; exit }')
                [[ $subid ]] && sub=("$subid")
                ;;
            SNAPSHOT=*)
                snapshotid=$(command vultr snapshot list | awk -F'\t+' -v description="${arg#SNAPSHOT=}" 'NR > 1 && $2 == description { print $1; exit }')
                [[ $snapshotid ]] && sub=("$snapshotid")
                ;;
            SCRIPT=*)
                scriptid=$(command vultr script list | awk -F'\t+' -v name="${arg#SCRIPT=}" 'NR > 1 && $2 == name { print $1; exit }')
                [[ $scriptid ]] && sub=("$scriptid")
                ;;
            %*)
                local -n preset=preset_${arg#%}
                if [[ ${preset@a} == *a* ]]; then
                    sub=("${preset[@]}")
                fi
                ;;
        esac
        args+=("${sub[@]:-$arg}")
    done
    command vultr "${args[@]}"
}
