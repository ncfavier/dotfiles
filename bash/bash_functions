args() {
    printf '%d\n' "$#"
    if (( $# )); then
        printf '<%s> ' "$@"
        echo
    fi
}

cd() {
    builtin cd "$@" && ls
}

mkcd() {
    mkdir -p "$@" && builtin cd "$@"
}

bck() {
    for f do
        cp -i -- "$f" "$f.bck"
    done
}

unbck() {
    for f do
        if [[ $f == *.bck ]]; then
            cp -i -- "$f" "${f%.bck}"
        else
            cp -i -- "$f.bck" "$f"
        fi
    done
}

vimx() {
    if [[ -x $1 ]]; then
        vim "$@"
    else
        vim -c 'autocmd BufWritePost * exec "!chmod +x" shellescape(expand("%"), 1) | autocmd! BufWritePost' "$@"
    fi
}

duh() {
    command du -h -d 1 "$@" | sort -k 1,1hr -k 2,2f
}

what() {
    local path
    if [[ $1 == */* ]]; then
        pacman -Fo "$1" ||
        pacman -Fo "$(realpath "$1")"
    else
        path=$(type -P "$1") || path=/usr/bin/$1
        pacman -Fo "$path"
    fi
}

attassh() {
    ssh -t "$1" screen -r "$2"
}

sshesc() {
    local args=() interactive=0 cmd
    while (( $# )); do
        if [[ $1 == -i ]]; then
            interactive=1
        elif [[ $1 == -- ]]; then
            shift
            if (( interactive )); then
                cmd=$*
                args=(-qt "${args[@]}" bash -lic "${cmd@Q}")
            else
                args+=("${@@Q}")
            fi
            break
        else
            args+=("$1")
        fi
        shift
    done
    ssh "${args[@]}"
}

sudofn() {
    sudo bash -c "$(declare -f "$1"); ${@@Q}"
}

sponge() {
    tmp=$(mktemp) && cat > "$tmp" && cat -- "$tmp" && rm -f -- "$tmp"
}

unfold() {
    tr -s '[:space:]' '[ *]'
}

unfoldclip() {
    clip | unfold | clip
}

alert() {
    command=("$@")
    if "${command[@]}"; then
        dunstify -t 10000 -i ok "${command[*]}" "succeeded"
    else
        dunstify -t 10000 -i error "${command[*]}" "failed"
    fi
}

insist() {
    command=("$@")
    until "${command[@]}"; do
        sleep 0.1
    done
}

http() {
    local port password source=${1-.} tmpdir response_fifo
    read -rp "Port? " port
    port=${port:-4242}
    if [[ -d $1 ]]; then
        read -rsp "Password? " password
        echo
        caddy -conf=<(echo ":${port:-12345}"; echo browse; [[ $password ]] && echo "basicauth / naim $password") ${1+-root="$1"}
    elif [[ -x $1 ]]; then
        [[ $source == */* ]] || source=./$source
        tmpdir=$(mktemp --tmpdir -d http-XXXXX) || return 1
        response_fifo=$tmpdir/reponse
        mkfifo "$response_fifo" || return 1
        echo "Serving $source at http://localhost:$port"
        while
            nc -l -p "$port" -N < "$response_fifo" | "$source" > "$response_fifo"
        do :; done
    else
        echo "Invalid source." >&2
    fi
}

myip() {
    dig +short myip.opendns.com @resolver1.opendns.com
}

pwd_short() {
    local prefix i ps1='\w'
    while read -rd/; do
        i=0
        while
            prefix=${REPLY::++i}
            [[ $prefix == +(.) ]]
        do :; done
        printf %s/ "$prefix"
    done <<< "${ps1@P}"
    printf '%s\n' "$REPLY"
}

remind() {
    local delay=$1
    shift
    {
        sleep "$delay"
        dunstify -i dialog-info -t 10000 "$*"
    } &> /dev/null & disown
}

mans() {
    man -P "less +/${2@Q}" "$1"
}

mock() {
    while IFS= read -rd '' -n 1 c; do
        (( RANDOM%2 )) && c=${c^^}
        printf %s "$c"
    done <<< "$*"
}

# Magic

clipcmd_helper () {
    local cmd
    local -a lines
    read -r _ _ cmd < <(history 1)
    mapfile lines < <(LC_ALL=en_US.UTF-8 eval "$cmd" 2>&1)
    printf %s "${lines[@]}"
    {
        printf '$ %s\n' "$cmd"
        printf %s "${lines[@]}"
    } | xsel -b -i
}

alias clipcmd='clipcmd_helper # '

# vim: syntax=sh
